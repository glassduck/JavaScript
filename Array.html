<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script>
        var a=["a","b","c"]
        a.push("d") //추가하고 배열의 길이값 반환
        a.push("e","f")
        a.pop();    //마지막 요소 반환
        a.shift();  //첫번째 요소 없애고 왼쪽으로 미는 거. 제거한 값 반환.
        a.unshift("k"); //맨 앞에 요소값 추가하고 오른쪽으로 미는 거. 배열의 길이 반환.

        var a=["a","b","c","d"];
        a.splice(1,2,"q","w","e");  //인덱스 1부터 2개를 없애고 qwe추가..없앤 2개를 반환값으로!
        a.splice(2);    //인덱스 2부터 브브
        a.splice(-1);   //뒤에서부터...
        a.splice(1,0,"q","w","e")   //인덱스 1 앞에 삽입!

        var a=[5,2,1,7,1,3,9,8];
        a.sort(function(a,b){return a-b});

        function compareFunc(key){
            return function(a,b){
                return a[key]-b[key];
            };
        };
        var persons=[{name:"Tom",age:17},{name:"Huck",age:18},{name:"Becky",age:16}];
        persons.sort(compareFunc("age"));

        a=["A","B","C"];
        a.join("-");
        a.join("");
        a.join();

        a.concat(["D","E"],["F","G"]);
        a.concat("D",["E",["F","G"]]);  //배열은 한번만 펼침. Not 2번!
        a.concat(1,"x",true);       //원시값이라면 anything!

        a.slice(0,-1);

        a.indexOf("C")  //앞에서부터 찾음
        a.lastIndexOf("C")  //뒤에서부터 찾음
        a.indexOf("C",3)    //인덱스 3부터 찾음.

        var date= new Date();
        [1,[2,3],date].toString();
        [1,[2,3],date].toLocaleString();

        var a=[1,2,3,4,5];
        var sum=0;
        a.forEach(function(value){sum+=value}); //대부분 일케 인수 하나로 함.
        console.log(sum);
        a.forEach(function(v,i,a){a[i]=v*v});   //하지만 원래는 3개라는 점~
        console.log(a);

        var b=a.map(function(x){return 2*x});
        var c=a.map(Math.sqrt);

        var persons=[
            {name:"Tom",age:17},
            {name:"Huck",age:18},
            {name:"Becky",age:16}
            ];
        var names=persons.map(person=>person.name);
        var ages=persons.map(person=>person.age);
        console.log(names);
        console.log(ages);
        persons.map(person=>person.name).map(name=>name.length);

        var a=[1,2,3,4,5];
        a.reduce(function(prev,value){return prev+value},0);
        a.reduce(function(prev,value){return prev+value},0);

        a.reduce(function(p,v){return p*v},1)
        a.reduce(function(p,v){return (p>v)?p:v},1)

        var c=["Tom","Huck","Becky"];
        c.reduce(function(p,v){return p+" "+v;});   
        c.reduce(function(p,v){p[v]=v.length;return p},{});

        function permutation(a){
            return a.reduce(function(list,element){
                var newlist=[];
                list.forEach(function(seq){
                    for(var i=seq.length;i>=0;i--){
                        var newseq=[].concat(seq);
                        newseq.splice(i,0,element);
                        newlist.push(newseq);
                    }
                });
                return newlist;
            },[[]]);
        }
        var t=[1,2,3,4];
        permutation(t).forEach(function(v){console.log(v);});

        var x=new Array(3); //빈 배열 3칸짜리 만드는 생성자.
        for(var i=0;i<3;i++){
            x[i]=new Array(3);
        }
        for(var count=1,i=0;i<3;i++){
            for(var j=0;j<3;j++){
                x[i][j]=count++;
            }
        }

        var N=3;
        for(var i=1,a=[];i<=N*N;i++) a=a.concat(i);
        var m=new Array(N);
        for(var i=0;i<N;i++) m[i]=new Array(N);
        function permutation(a){
            return a.reduce(function(list,element){
                var newlist=[];
                list.forEach(function(seq){
                    for(var i=seq.length;i>=0;i--){
                        var newseq=[].concat(seq);
                        newseq.splice(i,0,element);
                        newlist.push(newseq);
                    }
                });
                return newlist;
            },[[]]);
        };
        permutation(a).forEach(function(p){
            for(var i=0,index=0;i<N;i++){
                for(var j=0;j<N;j++){
                    m[i][j]=p[index++];
                }
            }
            if(isMagicSquare(m)){
                m.forEach(function(v){console.log(v)});
                console.log("nononononononono");
            }
        });
        function isMagicSquare(m){
            var n=m.length;
            var s=n*(n*n+1)/2;
            var sumDiagonalR=0;
            var sumDiagonalL=0;
            for(var i=0;i<n;i++){
                var sumRow=0;
                var sumColumn=0;
                for(var j=0;j<n;j++){
                    sumRow+=m[i][j];
                    sumColumn+=m[j][i]; //여기 m을 안써서 1시간 반을 찾았네~
                }
                if(sumRow != s || sumColumn != s) return false;
                sumDiagonalR+=m[i][i];
                sumDiagonalL+=m[i][n-i-1];
            }
            if(sumDiagonalR!=s || sumDiagonalL != s)return false;
            return true;
        }
        var x=new Array(3);
        for(var i=0;i<3;i++){
            x[i]=new Array(3);
            for(var j=0;j<3;j++){
                x[i][j]=new Array(3);
            }
        }
        for(var count=1,i=0;i<3;i++){
            for(var j=0;j<3;j++){
                x[i][j]=count++;
            }
        }

    </script>
</body>
</html>;